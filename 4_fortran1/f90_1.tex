\chapter{Fortran90の基礎１〜コンパイルと変数〜}

\section{はじめに}
今回から数回に渡ってプログラミングの初歩を学ぶ.
プログラミング（programing もしくは coding）とは,
コンピュータを意図した通りに動かすための指示書（ソースコード）を作成することである.

コンピュータは抽象的な内容を理解しないので, その指示書は具体的かつ厳密に記述する必要がある.
指示書を記述するための言語を``プログラミング言語''と呼ぶ.
この章では, Fortran90というプログラミング言語を用いたソフトウェア開発を体感し,
プログラミングに必要な概念や知識の初歩を学ぶ.

プログラミング技術の上達のためにはとにかく多くのプログラムを書くことが大切である.
テキストに掲載されているサンプルプログラムは,
全て自分で書き写して実行してみること.

\section{プログラムのコンパイルと実行}
はじめに, コマンドプロンプトを立ち上げる.
次にソースファイルを保存するためのディレクトリを適当な場所に作成する.
以下では, ホームディレクトリの下に, ``fortran''という名前のディレクトリを作成したものとして説明を進める.
ディレクトリの作成は, コマンドプロンプト上で,
\begin{Verbatim}[frame=single]
>mkdir fortran
\end{Verbatim}
と入力する. 続いて,
\begin{Verbatim}[frame=single]
>cd fortran
>notepad++ HelloWorld.f90
\end{Verbatim}
と入力すると,
ディレクトリ``fortran''に移動したのち, notepad++というエディタによって
``HelloWorld.f90"というファイルが開かれる
\footnote{もし, 各自の環境でnotepad++がインストールされていない場合は, 代わりに
\verb|>notepad HelloWorld.f90|
と入力することで, メモ帳を用いて``HelloWorld.f90"を開くことができる.
}.
%TODO 色がつくエディタを使わせたい

テキストファイル``HelloWorld.f90'に以下の枠内の内容を入力し, 保存する.
Fortranは大文字と小文字を区別しないため, どちらで書いても構わない.
\lstinputlisting[caption=HelloWorld.f90の中身. , label=helloworld]{4_fortran1/codes/HelloWorld.f90}
なお, クォーテーションマークの内側にある$_{\sqcup}$は半角スペースを意味する.
また, エクスクラメーションマーク(!)以降の緑色でハイライトされた部分はコメント文と呼ばれ,
プログラムの動作には影響を与えない文章である.
テキストのサンプルコードを真似て書くときには, コメント文を写す必要はないが,
自分でコードを書くときには, 分かりやすさのために積極的にコメント文を書くべきである.

プログラムは\verb|program| [プログラム名]で始まり, \verb|end program| [プログラム名]で終わる.
実際の命令は2行目と3行目に記述されている.
2行目の\verb|write|文は出力, 3行目の\verb|stop|文はプログラムの停止を表す.


ソースコードが書けたら, コマンドプロンプト上で次のように入力し, コンパイルする.
\begin{Verbatim}[frame=single]
>gfortran HelloWorld.f90 -o HelloWorld.exe
\end{Verbatim}
コンパイルとはソースコードから機械語への翻訳作業である.
正常にコンパイルが終了すれば, ディレクトリ``fortran''中に``HelloWorld.exe''という実行ファイルが生成される
\footnote{コンパイルオプション\verb|-o ***.exe|を指定することで, 実行ファイル(.exe)に任意の名前\verb|***|を付けることができる. }.
\begin{Verbatim}[frame=single]
>dir
\end{Verbatim}
と入力し, 確認してみよ.

最後に生成された実行ファイルを実行する. コマンドプロンプト上で,
\begin{Verbatim}[frame=single]
>HelloWorld.exe
\end{Verbatim}
と入力すれば, クォーテーションマークの内側に書いた文字列(サンプルプログラムではHello World!)が
そのまま画面上に表示される.

\section{電卓としての利用}
\subsection*{画面出力}
簡単な計算結果を画面に表示するプログラムを作成する.
\lstinputlisting[caption=電卓としての利用. , label=Calculator]{4_fortran1/codes/Calculator.f90}
このソースコードをコンパイルし, 実行せよ.
画面に``1+1'' の答えである``2'' と, ``3*2''の答えである``6''が表示されること確認せよ.
さらに3行目は, ``3*2''の計算を行うのではなく, ``3*2''と表示させている. この違いを確認せよ.

Fortran90では一行に書くことのできる文字数は132文字に限られている.
もしも一行が長くなるようであれば, 以下のように文末に\verb|&|(アンパサンド)を置くことで,
複数の行に分けて記述することができる.
\lstinputlisting[caption=継続行の記述方法. , label=Continuation]{4_fortran1/codes/Continuation.f90}


\subsection*{組込み関数}
Fortranには三角関数をはじめとする初等関数があらかじめ用意されており,
これらは組込み関数と呼ばれる.
平方根{\ttfamily sqrt}, 絶対値{\ttfamily abs}, 指数関数{\ttfamily exp}の使用例が以下である.
\lstinputlisting[caption={組込み関数. }, label=builtinfunction1]{4_fortran1/codes/BuiltinFunction1.f90}
Fortranで実数を表すときには, \verb|1.d0|のように\verb|.d0|を付けなければならないことに注意せよ(倍精度実数)
\footnote{もし, \verb|1.0|と書いてしまうと計算精度が悪くなる(単精度実数).
また, 整数を表すときには単に\verb|1|と書けばよい. }.

円周率$\pi$や自然対数の底$e$は逆三角関数や指数関数を用いて次のように計算できる.
%\footnote{変数を倍精度で宣言していたとしても, 関数の引数が単精度であれば戻り値も単精度になることに注意せよ.} \\
\lstinputlisting[caption={数学定数. }, label=builtinfunction2]{4_fortran1/codes/BuiltinFunction2.f90}


%三角関数の引数はラジアンで与えなければならない.
%度からラジアンへの変換には, 以下のプログラムのようにあらかじめ計算した円周率を利用する.
%\lstinputlisting[caption={三角関数. }, label=builtinfunction3]{4_fortran1/codes/BuiltinFunction3.f90}


\subsection*{$<$演習課題1.1$>$}
% この演習問題で, 変数の必要性を認識させる.
%対数や双曲線関数などを計算する関数が用意されている.
以下の計算結果を画面に表示するプログラムを作成せよ. なお, 一つのソースコード内に全て記述すること.
\begin{enumerate}
%TODO もう少し意味がありかつ計算が難しい例にする
\item $\sin 60^\circ$
\item $\cos 60^\circ$
\item $\tan 60^\circ$
%\item $\sin(1.0)$
%\item $\sin(\sin(1.0+\pi))$
%\item $\sqrt{\sin(\sin(1.0)+\pi)}$
\end{enumerate}
三角関数\verb|sin(), cos(), tan()|の引数はラジアンで与えなければならないことに注意せよ.

\section{変数}
上記の演習課題では, $60^\circ$を$\pi/3$に変換し, これを引数として繰り返し代入したが,
何度も同じ数式を打つのは非効率であるし, 間違いも起こりやすい.
そのためFortranには, 計算結果を格納して, 繰り返し利用することのできる{\bfseries 変数}という仕組みが用意されている.
以下は, 変数を利用するプログラムである.
\lstinputlisting[caption=変数を用いた計算. , label=variable]{4_fortran1/codes/Calculator2.f90}
2行目の\verb|implicit none|は暗黙の型宣言の禁止を意味し,
3行目の\verb|integer:: x|は\verb|x|という変数が整数型であることを明示的に示す構文である.
これらの意味については後述する.


なお, 変数に変数を用いた計算結果を代入することも可能である.
6行目の\verb|double precision:: c|は変数\verb|c|が倍精度実数型であることを宣言している.
\lstinputlisting[caption=変数を用いた計算2. , label=variable2]{4_fortran1/codes/Variables.f90}

演習課題1.1の三角関数の計算を変数を利用して行ったものが以下である.
\lstinputlisting[caption={変数を利用した三角関数の計算. }, label=builtinfunction3]{4_fortran1/codes/BuiltinFunction3_2.f90}


\subsection*{$<$演習課題1.2$>$}
上のソースコードの8行目は数学的には一見奇妙に感じられるかもしれない.
しかしながら, Fortranにおける\verb| = |は左辺の変数に右辺の値を代入する命令であり,
このような構文はしばしば現れる.
\begin{enumerate}
\item 倍精度実数型変数\verb|x|を宣言し,
\item \verb|x|に\verb|0.d0|を代入したのち,
\item \verb|x = x + 1.d0|を10回繰り返す
\end{enumerate}
とxの値はどうなるか.
プログラムを作成し, \verb| = |の意味を確認せよ.
\newline


\begin{comment}
\subsection*{より汎用的な電卓プログラムの作成}
%TODO この章はとりあえずなくてもよい気がする.
画面上で二つの数値x, yを読み取り, それらをそのまま画面上に表示するプログラムの例を以下に示す.
\lstinputlisting[caption=標準入出力を用いた電卓プログラム. , label=readwrite]{4_fortran1/codes/ReadWrite.f90}
このプログラムを実行すると, x, yという二つの数値の入力待ちとなるため,
キーボードから任意の数字を入力する.
x=1.2, y=3.14を入力するには,
\begin{Verbatim}[frame=single]
1.2 3.14
\end{Verbatim}
のようにスペースまたは,
\begin{Verbatim}[frame=single]
1.2
3.14
\end{Verbatim}
のようにエンターで区切る.

write文とread文の括弧の中の6と5は,
それぞれ標準出力, 標準入力と呼ばれ, コマンドプロンプトの画面上での入出力を意味する. \\


次に, 画面上で二つの数値x, yを読み取り, それらの和, 差, 積, 商を計算するプログラムを以下に示す.
\lstinputlisting[caption=四則演算. , label=fouroperations]{4_fortran1/codes/FourOperations.f90}
和差積商はそれぞれ記号$+-*/$で表される.
\\

% TODO 出力・入力は, 必要性を感じさせてから紹介する.
最後に, 二つの数値をファイルから入力するように変更したプログラムを以下に示す.
\lstinputlisting[caption=ファイル入力. , label=fileinput]{4_fortran1/codes/FileInput.f90}
プログラムの実行にあたっては, あらかじめ``input.dat''という入力ファイルを準備しておく必要がある.
メモ帳を用いて, ファイル``input.dat''をソースコードと同じフォルダ内に作成し, 例えば次のように入力しておくこと.
\begin{Verbatim}[frame=single]
1.2 3.14
\end{Verbatim}
\end{comment}

これまでにいくつか例題を示した通り, コンピュータは整数と実数を区別して扱う.
そのため, 計算結果を格納する変数がどちらの型に相当するのかを予めコンピュータに伝える必要がある.
%前述ソースコード中の{\ttfamily integer x} は, 変数{\ttfamily x}が整数型(integer)であることを示す.
これを変数の宣言といい, プログラムの冒頭に記述する.
Fortranにおいて整数と実数は, それぞれ整数型(integer), 倍精度実数型(double precision)
\footnote{実数型には単精度実数型(real)というものも存在する.
倍精度実数型は十進数で約16桁の精度をもつのに対し,
単精度実数型の精度は約7桁である.
特別の理由がない限り, 実数型の計算においては倍精度実数型を用いるのが普通である.
}と呼ばれる形式で扱われる.

コンピュータに数値計算をさせる時には, 状況に応じて実数と整数を区別し取り扱うことが重要となる.
数学的には整数は実数に含まれるため, 全ての変数を常に実数型として宣言しておけばよいかと言うと, そうではない.
確かに, 以後のプログラムで出てくる変数の大半は倍精度実数型として宣言されるが,
例えば, 1, 2, 3, $\cdots$と離散的に数え上げられるもの(次章で学ぶdoループ等)には整数型を用いなければならない.

型の違いが計算結果にどのように影響するか, 次のプログラムを実行することで確かめてみよ.
\lstinputlisting[caption={整数型, 実数型. }, label=variabletype]{4_fortran1/codes/VariableType.f90}
プログラム中の3, 4行目が変数型を宣言している部分である.
もしも変数型を明示的に宣言しないと, a-h, o-zで始まる変数は``単精度''実数型,
i-nで始まる変数は整数型として自動的に扱われる(暗黙の型宣言).
プログラムの冒頭に記した\verb|implicit none|は暗黙の型宣言を禁止する命令であり,
宣言をしていない変数を使用するとコンパイルエラーになる.
暗黙の型宣言を禁止することで, タイプミスや変数型の勘違いなどを防ぐことができるので,
バグの入りにくいプログラムを書くことができる.

値の書き方は用いる変数型によって異なる.
例えば10という値は, 整数型ではそのまま\verb|10|と書けばよいが,
倍精度実数型では\verb|10.d0, 1.d1, 1.0d1, 1.d+1|などと書く.

また, 12行目の\verb|dble|は整数型から倍精度実数型への変換をおこなう関数である. \\


\subsection*{$<$演習課題1.3$>$}
% 余弦定理
余弦定理を用いて, 3辺の長さが4 cm, 5 cm, 6 cmの三角形の内角を全て求めるプログラムを作成せよ.

\subsection*{画面入力}
先に示した三角関数の値を計算プログラムにおいて, 引数の値は$60^\circ$に固定されており,
別の値, 例えば$30^\circ, 100^\circ$を引数に計算しようとすると, ソースコードを書き替え,
再度コンパイルしなければならない.
これは面倒なだけではなく, プログラムの汎用性$\cdot$保守性の観点からも良くない.
そこで, 引数\verb|theta|だけを外部から入力するように書き換えたのが以下のプログラムである.
\lstinputlisting[caption={汎用的な三角関数の計算. }, label=builtinfunction3]{4_fortran1/codes/BuiltinFunction3_3.f90}

8行目の\verb|read|文が画面上からの入力を受け付ける命令である.
プログラムを実行すると入力待ち状態となるので,
\begin{Verbatim}[frame=single]
180.d0
\end{Verbatim}
などと打ち込むと, \verb|theta = 180.d0|として計算が実行される.


\subsection*{$<$演習課題1.4$>$}
半径1の円に内接する正$n$角形の周の長さを計算するプログラムを作成せよ.
十分に大きな$n$に対しては, 周の長さは円周$2\pi$の近似となるが,
その相対誤差は$n$の何乗に比例して小さくなるか調べよ
($n=10, 100, 1000, 10000$とすると相対誤差はどのように減少するか?).


\section{その他の注意}
本章で説明したプログラムは比較的簡単なものばかりであるが,
テキストを読み進めていくにつれて, 次第に高度な内容を取り扱うことになる.
そのときに直面しうる問題について, あらかじめその対処法を述べておく.
今はよく分からなくても, 頭の片隅においておき, 必要に応じて参照せよ.

\subsection{プログラムの強制終了}
(数分以内に終わらないような)プログラムの実行中にプログラムの誤りに気づいた,
あるいは条件分岐の記述を間違えてプログラムが無限ループに陥ってしまったような場合,
コンソール上で\verb|Ctrl + c|と入力することで,
プログラムを強制的に終了することができる.

\subsection{プログラムのバグ}
プログラムにバグはつきものである.
いくら注意深くプログラムを記述しても, 一発で正しいプログラムを書き上げることは至難の業である.
言うまでもなく, 大規模なプログラムになるとバグとりに相当な時間を要することになる.
\textbf{書いたプログラムとにらめっこしてバグを探そうとする人がいるが, そのような方法では
いつまでたってもバグは見つからない.}
プログラムの書き手は, 自分の書いたプログラムが正しいと信じて書いているので,
何らかの客観的な形でプログラムの真偽を吟味する必要がある. \\

そもそもコンパイルエラーで実行ファイル(.exe)が生成されないときには,
\begin{enumerate}
\item コンソール上にエラーメッセージが表示されるので, これをよく読む.

英語だからといって恐れる必要はない. いくつかの単語を知っておけば, その意味は容易に理解できるだろう.
コンパイラによって多少の違いはあるが, 例えば以下のようなエラーメッセージが表示される.
\begin{Verbatim}[frame=single]
 write(6.*) a
        1
Error: Syntax error in WRITE statement at (1)
\end{Verbatim}
3行目において, (1)の部分のwrite文に文法エラーがあります, と指摘されている.
(1)のついた部分をよく見ると\verb|(6,*)|ではなく, \verb|(6.*)|となっている.
\end{enumerate}

続いて, コンパイルが正常にできたからといって, できあがった実行ファイルが正しいと信じるのは早計である.
明らかに間違った出力が返ってくるときには以下の項目を試してみよ.

\begin{enumerate}
\setcounter{enumi}{1}
\item プログラムの冒頭に\verb|implicit none|文を記述する.

以前にも述べたが,
変数名のスペルミスや変数型の勘違いをあらかじめ防ぐことができる.

\item プログラムの途中に\verb|write|文を挿入する.

プログラムのどこまでが正しくて, どこからが間違っているのかを切り分けるのは
重要な作業である.
少し面倒ではあるが, 途中に\verb|write|文を挿入し, 変数の値が正しいかどうかを逐次確認することで,
バグのありかを特定することができる.

\item プログラムを要素に分ける.

一般に長いプログラムにはバグが入りやすい.
それならば, プログラムを小さな小問題に分割して(後に述べるサブルーチン化),
その要素ごとにチェックをしてやればよい.
例えるならば, 自動車を全て組み上げてから正常に走るかをチェックするのではなく,
エンジン, ステアリング, ブレーキなどのパーツごとに動作確認をするわけである.

\item 答えの分かっている問題を解く.

いきなり未知の問題を解こうとしても, 出力された答えが正しいかどうかは誰にも判定できない.
あくまで必要条件としてであるが, 手計算で答えの求められる問題に対して,
正しい答えが得られるかを確認しておくことは重要である.

\item そもそも定式化やアルゴリズムを疑う.

前提としている方程式やアルゴリズムが正しいものかどうか,
あらかじめ自分の手を動かして確認せよ.

\item 適度な休憩を入れる.

プログラミングは頭脳労働である一方, 肉体労働という側面もある.
頭と目を酷使しすぎると, 見つかるはずのバグも見つからない.
見つからないときには見つからないものだと割り切って, 適度に休憩をはさむのがよい.
一晩おいてみると, 意外に初歩的な間違いに気づいた, ということはよくある.

\end{enumerate}




\begin{comment}
Fortranは文字も変数として扱うことができる(文字型: character).
文字の長さはcharacter(len=5)などとして指定する.
次のプログラムは文字型を扱った例である.
\lstinputlisting[caption={文字型. }, label=variabletype2]{4_fortran1/codes/VariableType2.f90}


\subsection*{$<$演習課題$>$}
二辺の長さとそれらのなす角度を読み取り, その三角形の面積を計算するプログラムを作成せよ. \\
\end{comment}

\begin{comment}
異なる型同士の演算は文法エラーではないが,
避けることが望ましい.
以下のプログラムは, 整数型, 実数型, 複素数型間の型変換の例である.
\lstinputlisting[caption={型変換. }, label=builtinfunction4]{4_fortran1/codes/BuiltinFunction4.f90}
\end{comment}
